@startuml

class abc.ABCMeta <<metaclass>>

package scheduler.task {
    abstract class Task {
        + command: str
        + trigger_args: any
        + {abstract} run_date_iter: Iterator[datetime]
        + to_dict(): Dict
    }
    Task --r|> db.models.TaskModel
    Task .--> abc.ABCMeta

    class CronTask {
        + run_date_iter: Iterator[datetime]
    }
    class IntervalTask{
        + run_date_iter: Iterator[datetime]
        + <<r/o>> interval: timedelta
        + {static} validate(int): bool
    }
    class DateTask{
        + run_date_iter: Iterator[datetime]
    }
    CronTask     .-u|> Task
    IntervalTask .-u|> Task
    DateTask     .-u|> Task

    class TaskFactory {
        - {static} _trigger_type_mapping = Dict[str, Type[Task]]
        - {static} _get_class(str): Type[Task]
        + {static} create(str, str, str): Task
        + {static} create_from_kwargs(str, str, Dict): Task
    }
    TaskFactory .-u> CronTask
    TaskFactory .-u> IntervalTask
    TaskFactory .-u> DateTask
}

class db.connection.Session
db.connection.Session "*" o.-r "1" db.connection.engine

package db.models {
    class Base
    Base .r> DeclarativeABCMeta

    class ExecutionLog {
        + {static} execution_log_id: Column
        + {static} task_id: Column
        + {static} status: Column
        + {static} start_date: Column
        + {static} finish_date: Column
        + {static} return_code: Column
    }


    class ConsoleLog {
        + {static} execution_output_log_id: Column
        + {static} execution_log_id: Column
        + {static} message: Column
        + {static} time: Column
        + to_dict(): Dict
    }
    ConsoleLog .--u|> Base
    ConsoleLog .--u> abc.ABCMeta

    class StdoutLog
    class StderrLog
    StdoutLog .-u|> ConsoleLog
    StderrLog .-u|> ConsoleLog

    class TaskModel {
        + {static} task_id: Column
        + {static} command: Column
        + {static} trigger_type: Column
        + {static} trigger_args: Column
    }

    ExecutionLog .--u|> Base
    TaskModel .-|> Base

    class DeclarativeABCMeta <<metaclass>>
    DeclarativeABCMeta --|> abc.ABCMeta
}

package scheduler.executor {
    class TaskExecutor {
        + <<r/o>> task: Task
        - _loop: EventLoop
        - _timer_handle: TimerHandle
        + status: str
        + <<r/o>> active: bool

        + run()
        + stop()
        + update_status(str)
        + to_dict(): Dict
        - _sched_next_run(datetime): TimerHandle
        - _log_missed(datetime)
        - _get_next_run_ts(): float
        - _run_iteration()
    }
    TaskExecutor *.-r Execution
    TaskExecutor "1" *.---u "1" db.models.ExecutionLog

    class Execution {
        - _task: Task
        - _status_callback: Callable
        + <<r/o>> status: str
        + start(): int
        - _execute_process(): int
        - _log_start()
        - _log_finish()
    }
    Execution "1" *.---u "*" db.models.StdoutLog
    Execution "1" *.---u "*" db.models.StderrLog

    class ExecutionManager {
        + task_executors: Dict[int, TaskExecutor]
        + sync()
        + run_task(int)
        + run_all()
        + stop_task(int)
        + stop_all()
        - _update_db_tasks(List[Task])
        - _add_task(Task)
        - _update_task(TaskExecutor, Task)
        - _delete_db_tasks(List[Task])
    }

    TaskFactory *. db.connection.Session
    Execution *.-l db.connection.Session
    ExecutionManager *.-- db.connection.Session
    ExecutionManager "1" *.-u "*" TaskExecutor
}

package db.dal {
    class DAL {
        + session: AsyncSession
        + execution_manager: ExecutionManager
        + get_tasks(): List[Task]
        + get_task(int): Task
        + add_task(TaskInputModel)
        + delete_task(int)
        + update_task(int, TaskInputModel)
        + get_execution_logs(): List[ExecutionLog]
        + get_execution_log(int): ExecutionLog
        + get_execution_output_logs(int, int): List[StdoutLog]
    }

    DAL "*" *.---u "1" db.connection.Session
    DAL "*" o-.-u "1" ExecutionManager
    DAL o.-u db.models.ExecutionLog
    DAL o.-u db.models.StdoutLog
    DAL o.-r api.models.TaskInputModel
}

class api.models.TaskInputModel {
    + {static} task_id: Optional[int]
    + {static} command: str
    + {static} trigger_type: str
    + {static} trigger_args: Union[str, Dict]
}

package api.app {
    class FastAPI {
        app
    }
    class Config {
        config
    }
    class Server {
        server
    }

    Server o-d Config
    Config o-d FastAPI
    FastAPI o.- api.routers
}

package api.routers {
    class task_router {
        + get_tasks(DAL)
        + get_task(DAL, int)
        + add_task(DAL, TaskInputModel)
        + delete_task(DAL, int)
        + update_task(DAL, int, TaskInputModel)
    }
    task_router o.-d api.models.TaskInputModel

    class task_executor_router {
        + get_executors()
        + get_executor(int)
        + stop_executor(int)
    }
    task_executor_router o. ExecutionManager

    class execution_log_router {
        + get_execution_logs(DAL)
    }

    class execution_output_log_router {
        + get_execution_output_logs(DAL, int, Optional[int])
    }


    execution_output_log_router -[hidden]d- task_executor_router
    execution_log_router -[hidden]d- task_router

}

api.routers *.-r DAL

package util {
    class SingletonMeta {
        - _instances: Dict[Type, object]
        + __call__(Type, ...): object
    }

    class TaskOutputLogger {
        - _loop: EventLoop
        - _buffer: Deque[StdoutLog]
        + log(StdoutLog)
        + flush()
        - _flush_periodically(int)
    }
    TaskOutputLogger "1" *.- "1" db.connection.Session
    TaskOutputLogger "1" .--* "1" TaskExecutor
    TaskOutputLogger "1" .--* "1" Execution

    SingletonMeta .u> TaskOutputLogger
    ExecutionManager .u> SingletonMeta
}

@enduml